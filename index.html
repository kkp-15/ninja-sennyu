<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>å¿è€…æ½œå…¥ğŸ¯</title>
<style>
  body {
    font-family: sans-serif;
    text-align: center;
    background: #f4f4f4;
  }
  h1 { margin: 0.5em 0; }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 40px);
    justify-content: center;
    gap: 2px;
    margin: 10px auto;
  }
  .cell {
    width: 40px;
    height: 40px;
    background: #ccc;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    font-weight: bold;
  }
  .safe { background: #fff; }
  .trap { background: #e57373; color: #fff; }
  .castle { background: gold; }
  .start { background: #64b5f6; }
</style>
</head>
<body>

<h1>å¿è€…æ½œå…¥ğŸ¯</h1>
<p>å·¦ç«¯ã‹ã‚‰ğŸ¯ã¾ã§å®‰å…¨ãƒ«ãƒ¼ãƒˆã‚’é–‹ã‘ã‚ï¼æ–œã‚ã¯ã¤ãªãŒã‚‰ãªã„ã€‚</p>
<div id="board"></div>
<p id="message"></p>
<button onclick="init()">ã‚‚ã†ä¸€åº¦</button>

<script>
const size = 8;
const traps = 10; // ç½ ã®æ•°
let board, revealed;
const castlePos = {x: size-1, y: Math.floor(size/2)};

function init() {
  board = Array.from({length:size},()=>Array(size).fill(0));
  revealed = Array.from({length:size},()=>Array(size).fill(false));

  // ç½ ã‚’ãƒ©ãƒ³ãƒ€ãƒ é…ç½®ï¼ˆåŸã¨å·¦ç«¯ã¯é™¤å¤–ï¼‰
  let placed = 0;
  while (placed < traps) {
    let x = Math.floor(Math.random()*size);
    let y = Math.floor(Math.random()*size);
    if ((x===castlePos.x && y===castlePos.y) || x===0) continue;
    if (board[y][x] === "B") continue;
    board[y][x] = "B";
    placed++;
  }

  drawBoard();
}

function drawBoard() {
  const boardDiv = document.getElementById("board");
  boardDiv.innerHTML = "";
  for (let y=0; y<size; y++) {
    for (let x=0; x<size; x++) {
      const cell = document.createElement("div");
      cell.className = "cell";
      if (x===0) cell.classList.add("start");
      if (x===castlePos.x && y===castlePos.y) {
        cell.textContent = "ğŸ¯";
        cell.classList.add("castle");
      }
      if (revealed[y][x]) {
        if (board[y][x] === "B") cell.classList.add("trap");
        else cell.classList.add("safe");
      }
      cell.addEventListener("click", ()=>openCell(x,y));
      boardDiv.appendChild(cell);
    }
  }
}

function openCell(x,y) {
  if (revealed[y][x]) return;
  revealed[y][x] = true;
  if (board[y][x] === "B") {
    document.getElementById("message").textContent = "ğŸ’¥ ç½ ã«ã‹ã‹ã£ãŸï¼";
    revealAll();
    return;
  }
  drawBoard();
  if (checkClear()) {
    document.getElementById("message").textContent = "ğŸ‰ æ½œå…¥æˆåŠŸï¼";
  }
}

function revealAll() {
  for (let y=0; y<size; y++) for (let x=0; x<size; x++) revealed[y][x] = true;
  drawBoard();
}

// å·¦ç«¯ã‹ã‚‰ğŸ¯ã¾ã§ä¸Šä¸‹å·¦å³ã®ã¿ã§ã¤ãªãŒã£ã¦ã„ã‚‹ã‹ã‚’ç¢ºèª
function checkClear() {
  const visited = Array.from({length:size},()=>Array(size).fill(false));
  const q = [];
  for (let y=0; y<size; y++) {
    if (revealed[y][0] && board[y][0] !== "B") {
      q.push({x:0,y});
      visited[y][0] = true;
    }
  }
  while (q.length) {
    const {x,y} = q.shift();
    if (x === castlePos.x && y === castlePos.y) return true;
    for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
      const nx = x+dx, ny = y+dy;
      if (nx>=0 && nx<size && ny>=0 && ny<size && !visited[ny][nx] && revealed[ny][nx] && board[ny][nx] !== "B") {
        visited[ny][nx] = true;
        q.push({x:nx,y:ny});
      }
    }
  }
  return false;
}

init();
</script>

</body>
</html>
